#-valtan(cl:in-package :valtan-core)
#+valtan(cl:in-package :common-lisp)

(cl:defmacro ffi:define-function (name arguments cl:&body body)
  `(cl:progn
    (ffi:var ,name)
    (ffi:set
     ,(cl:cond ((cl:stringp name) name)
               ((cl:and (cl:symbolp name)
                        (cl:string= "JS" (cl:package-name (cl:symbol-package name))))
                name)
               (cl:t (cl:string name)))
     (cl:lambda ,arguments ,@body))))

(cl:defmacro ffi:define (var value)
  `(cl:progn
    (ffi:var ,var)
    (ffi:set
     ,(cl:cond ((cl:stringp var) var)
               ((cl:and (cl:symbolp var)
                        (cl:string= "JS" (cl:package-name (cl:symbol-package var))))
                var)
               (cl:t (cl:string var)))
     (ffi:cl->js ,value))))

(cl:defun ffi::%object (cl:&rest plist)
  (cl:let ((object (js::-object)))
    (cl:do ((cl:rest plist (cl:cddr cl:rest)))
        ((cl:null cl:rest))
      (cl:let ((key (cl:car cl:rest)) (value (cl:cadr cl:rest)))
        (ffi:set
         (ffi:aget object
                   (cl:cond ((cl:stringp key) (ffi:cl->js key))
                            ((cl:keywordp key)
                             (ffi:cl->js (compiler::kebab-to-lower-camel-case (cl:string key))))
                            (cl:t key)))
         value)))
    object))

(cl:defmacro ffi:object (cl:&rest plist)
  (cl:let ((new-plist 'cl:nil))
    (cl:do ((plist plist (cl:cddr plist)))
           ((cl:null plist))
      (cl:let ((key (cl:car plist)) (value (cl:cadr plist)))
        (cl:push
         (cl:cond ((cl:stringp key) `(ffi:cl->js ,key))
                  ((cl:keywordp key)
                   `(ffi:cl->js ,(compiler::kebab-to-lower-camel-case (cl:string key))))
                  (cl:t key))
         new-plist)
        (cl:push value new-plist)))
    `(ffi::%object ,@(cl:nreverse new-plist))))

(cl:defun ffi:array (cl:&rest args)
  (cl:apply (ffi:ref "Array") args))

(cl:defun ffi:js-eval (x)
  (cl:let* ((code (cl:format cl:nil "(function(lisp) { 'use strict'; ~A; });" x))
            (fn (js::eval (ffi:cl->js code))))
    (cl:funcall fn (ffi:ref "lisp"))))

(cl:defun ffi:cl->js (value)
  (cl:cond ((cl:stringp value) (array-contents value))
           ((cl:vectorp value) (array-contents value))
           ;; ((listp value)
           ;;  (*:list-to-js-array value))
           ;; ((eq value t)
           ;;  (ffi:ref "true"))
           ;; ((eq value nil)
           ;;  (ffi:ref "false"))
           ;; ((functionp value)
           ;;  (lambda (&rest args)
           ;;    (apply value (mapcar #'ffi:cl->js args))))
           (cl:t value)))

(cl:defun ffi:js->cl (value)
  (cl:cond
    ((cl:eq (ffi:typeof value)
            (*:array-to-js-string "string"))
     (*:js-string-to-array value))
    ((ffi:instanceof value (ffi:ref "Array"))
     (*:js-array-to-array value))
    ;; ((eq value (ffi:ref "true"))
    ;;  t)
    ;; ((eq value (ffi:ref "false"))
    ;;  nil)
    (cl:t value)))
