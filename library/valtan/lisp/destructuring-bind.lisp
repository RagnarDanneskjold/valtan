(in-package :common-lisp)

(defun %db-length (list)
  (do ((l list (cdr l))
       (count 0 (+ count 1)))
      ((atom l) count)))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defvar *db-bindings*)
  (defvar *tmp-db-vars*)

  (defun parse-db-lambda-list (lambda-list arg)
    (macrolet ((%push (x list)
                 `(setq ,list (cons ,x ,list)))
               (%pop (list)
                 `(prog1 (car ,list)
                    (setq ,list (cdr ,list))))
               (%incf (var &optional (n 1))
                 `(setq ,var (+ ,var ,n))))
      (flet ((db-gensym (&optional arg)
               (car (%push (if arg (gensym arg) (gensym)) *tmp-db-vars*)))
             (make-keyword (x)
               (intern (string x) :keyword))
             (invalid-lambda-list ()
               (error "Invalid lambda list: ~S" lambda-list)))
        (let ((path arg)
              (min 0)
              (max 0)
              (state nil)
              (optionalp nil)
              (restp nil)
              (keyp nil)
              (keys nil)
              (allow-other-keys-p nil)
              (check-arg-placeholder)
              (check-key-placeholder))
          (%push (setq check-arg-placeholder (list (db-gensym) nil)) *db-bindings*)
          (when (eq '&whole (first lambda-list))
            (%pop lambda-list)
            (unless lambda-list
              (invalid-lambda-list))
            (%push (list (%pop lambda-list) arg) *db-bindings*))
          (do ((ll lambda-list (rest ll)))
              ((atom ll)
               (when ll
                 (setq restp t)
                 (%push (list ll path) *db-bindings*)))
            (let ((x (first ll)))
              (cond ((eq state :aux)
                     (cond ((symbolp x)
                            (%push (list x nil) *db-bindings*))
                           ((consp x)
                            (case (length x)
                              ((1 2)
                               (%push (list (first x)
                                            (second x))
                                      *db-bindings*))
                              (otherwise
                               (invalid-lambda-list))))
                           (t
                            (invalid-lambda-list))))
                    ((eq x '&aux)
                     (setq state :aux))
                    ((eq x '&allow-other-keys)
                     (unless (eq state :key) (invalid-lambda-list))
                     (setq allow-other-keys-p t))
                    ((eq x '&key)
                     (when keyp
                       (invalid-lambda-list))
                     (%push (setq check-key-placeholder (list (db-gensym) path)) *db-bindings*)
                     (setq state :key)
                     (setq keyp t))
                    ((eq state :key)
                     (%incf max 2)
                     (cond ((symbolp x)
                            (let ((key (make-keyword x)))
                              (%push key keys)
                              (%push (list x `(getf ,path ,key))
                                     *db-bindings*)))
                           ((consp x)
                            (let ((len (length x)))
                              (cond ((<= 1 len 3)
                                     (let ((key (make-keyword (first x))))
                                       (%push key keys)
                                       (let ((supplied-value (db-gensym))
                                             (default ''#:default))
                                         (%push (list supplied-value `(getf ,path ,key ,default))
                                                *db-bindings*)
                                         (when (= len 3)
                                           (%push (list (third x) `(eq ,supplied-value ,default))
                                                  *db-bindings*))
                                         (%push (list (first x) `(if (eq ,supplied-value ,default)
                                                                     ,(second x)
                                                                     ,supplied-value))
                                                *db-bindings*))))
                                    (t
                                     (invalid-lambda-list)))))
                           (t
                            (invalid-lambda-list))))
                    ((member x '(&rest &body))
                     (setq restp t)
                     (cond ((and (rest ll) (symbolp (second ll)))
                            (%push (list (second ll) path) *db-bindings*)
                            (%pop ll))
                           ((and (rest ll) (consp (second ll)))
                            (let ((tmp (db-gensym "TMP")))
                              (%push (list tmp path) *db-bindings*)
                              (parse-db-lambda-list (second ll) tmp)))
                           (t
                            (invalid-lambda-list))))
                    ((eq x '&optional)
                     (when optionalp
                       (invalid-lambda-list))
                     (setq state :optional)
                     (setq optionalp t))
                    ((eq state :optional)
                     (%incf max)
                     (cond ((symbolp x)
                            (%push (list x `(first ,path)) *db-bindings*)
                            (let ((cdr-var (db-gensym "TMP")))
                              (%push (list cdr-var `(rest ,path)) *db-bindings*)
                              (setq path cdr-var)))
                           ((consp x)
                            (let ((len (length x)))
                              (cond ((<= 1 len 3)
                                     (when (= len 3)
                                       (%push (list (third x) `(if ,path t nil))
                                              *db-bindings*))
                                     (%push (list (first x) `(if ,path (first ,path) ,(second x)))
                                            *db-bindings*)
                                     (let ((cdr-var (db-gensym "TMP")))
                                       (%push (list cdr-var `(rest ,path)) *db-bindings*)
                                       (setq path cdr-var)))
                                    (t
                                     (invalid-lambda-list)))))
                           (t
                            (invalid-lambda-list))))
                    ((listp x)
                     (%incf min)
                     (%incf max)
                     (let ((car-var (db-gensym "TMP")))
                       (%push (list car-var `(first ,path)) *db-bindings*)
                       (parse-db-lambda-list x car-var))
                     (let ((cdr-var (db-gensym "TMP")))
                       (%push (list cdr-var `(rest ,path)) *db-bindings*)
                       (setq path cdr-var)))
                    (t
                     (unless (symbolp x) (invalid-lambda-list))
                     (%incf min)
                     (%incf max)
                     (%push (list x `(first ,path)) *db-bindings*)
                     (let ((cdr-var (db-gensym "TMP")))
                       (%push (list cdr-var `(rest ,path)) *db-bindings*)
                       (setq path cdr-var))))))
          (rplaca (cdr check-arg-placeholder)
                  `(unless ,(if (or restp keyp)
                                `(<= ,min (%db-length ,arg))
                                `(<= ,min (%db-length ,arg) ,max))
                     (error "Invalid number of arguments for destructuring-bind: ~S ~S" ',lambda-list ,arg)))
          (when (and check-key-placeholder
                     (not allow-other-keys-p))
            (rplaca (cdr check-key-placeholder)
                    (let ((plist (gensym)))
                      `(do ((,plist ,(second check-key-placeholder) (cddr ,plist)))
                           ((null ,plist))
                         (unless (or ,@(mapcar (lambda (key) `(eq ,key (first ,plist))) keys))
                           (error "Unknown &key argument: ~S" (first ,plist)))))))))))

  (defun expand-destructuring-bind (lambda-list expression body)
    (let ((*db-bindings* '())
          (*tmp-db-vars* '())
          (g-expression (gensym)))
      (parse-db-lambda-list lambda-list g-expression)
      `(let ((,g-expression ,expression))
         (let* ,(nreverse *db-bindings*)
           (declare (ignorable . ,*tmp-db-vars*))
           ,@body)))))

(*:defmacro* destructuring-bind (lambda-list expression &rest body)
  (expand-destructuring-bind lambda-list expression body))
